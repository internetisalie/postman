package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"
)

const (
	Package      = "main"
	TestFilename = "api_test.go"
	PostmanJSON  = "postman.json"
	RouterFunc   = "Router()"
)

var (
	replacements map[string]string
)

func main() {

	// replace postman variables with your own
	replacements["endpoint"] = "https://api.elementchains.com"
	replacements["coin"] = "eth"
	replacements["address"] = "0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1"

	generateApiTest()

}

func init() {
	replacements = make(map[string]string)
}

func generateApiTest() {
	testData := headerText()
	err := os.Remove(TestFilename)
	if err != nil {
		fmt.Println(err)
	}
	postmanData, err := ioutil.ReadFile(PostmanJSON)
	if err != nil {
		panic(err)
	}
	var post *Postmaner
	jsonData := string(postmanData)
	for k, e := range replacements {
		jsonData = strings.Replace(jsonData, fmt.Sprintf("{{%v}}", k), e, -1)
	}
	err = json.Unmarshal([]byte(jsonData), &post)
	if err != nil {
		panic(err)
	}

	for _, v := range post.Item {
		httpTests := []string{}
		fmt.Printf("Rendering Group: %v\n", v.Name)

		for _, item := range v.Item {
			fmt.Printf("  URL: %v | Method: %v\n", item.Request.URL.Raw, item.Request.Method)
			innerData := `
		{
            Name: "` + item.Name + `",
            URL: "` + item.Request.URL.Raw + `",
            Method: "` + item.Request.Method + `",
            Body: nil,
            ExpectedStatus: 200,
            ExpectedContains: nil,
        }`
			httpTests = append(httpTests, innerData)
		}

		testData += `
// TestPostman` + v.Name + ` runs all the Postman tests within the ` + v.Name + ` group.
func TestPostman` + v.Name + `(t *testing.T) {

	tests := []HTTPTest{` + strings.Join(httpTests, ",") + `}

    for _, v := range tests {
        t.Run(v.Name, func(t *testing.T) {
            run, err := RunHTTPTest(v)
            assert.Nil(t, err)
            body, err := ioutil.ReadAll(run.Body)
            assert.Nil(t, err)
            assert.Equal(t, v.ExpectedStatus, run.StatusCode)
            if v.ExpectedContains != nil {
                stringBody := string(body)
                for _, c := range v.ExpectedContains {
                    assert.Contains(t, stringBody, c)
                }
            }
            t.Logf("Test %v got: %v\n", v.Name, string(body))
        })
	}

}
`
	}

	fmt.Printf("Writing to test file: %v \n", TestFilename)
	f, err := os.Create(TestFilename)
	if err != nil {
		panic(err)
	}
	f.WriteString(testData)

	defer f.Close()
}

func headerText() string {
	return `// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// ` + time.Now().String() + `
// 
// This contains Go HTTP testing rendered from a postman JSON export

package ` + Package + `

import (
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

// HTTPTest contains all the parameters for a HTTP Unit Test
type HTTPTest struct {
    Name string
    URL string
    Method string
    Body string
    ExpectedStatus int
    ExpectedContains []string
}

// RunHTTPTest accepts a HTTPTest type to execute the HTTP request
func RunHTTPTest(test HTTPTest) (*http.Response, error) {
    req, err := http.NewRequest(test.Method, test.URL, strings.NewReader(test.Body))
    if err != nil {
        return nil, err
    }
    rr := httptest.NewRecorder()
    ` + RouterFunc + `.ServeHTTP(rr, req)
    return rr.Result(), err
}
`
}

type Info struct {
	PostmanID string `json:"_postman_id"`
	Name      string `json:"name"`
	Schema    string `json:"schema"`
}

type Item struct {
	Name string    `json:"name"`
	Item []SubItem `json:"item"`
}

type SubItem struct {
	Name     string        `json:"name"`
	Request  Request       `json:"request"`
	Response []interface{} `json:"response"`
}

type Request struct {
	Method string      `json:"method"`
	Header interface{} `json:"header"`
	Body   Body        `json:"body"`
	URL    URL         `json:"url"`
}

type URL struct {
	Raw  string   `json:"raw"`
	Host []string `json:"host"`
	Path []string `json:"path"`
}

type Body struct {
	Mode string `json:"mode"`
	Raw  string `json:"raw"`
}

type Auth struct {
	Type   string `json:"type"`
	Bearer []struct {
		Key   string `json:"key"`
		Value string `json:"value"`
		Type  string `json:"type"`
	} `json:"bearer"`
}

type Event struct {
	Listen string `json:"listen"`
	Script struct {
		ID   string   `json:"id"`
		Type string   `json:"type"`
		Exec []string `json:"exec"`
	} `json:"script"`
}

type Variable struct {
	ID    string `json:"id"`
	Key   string `json:"key"`
	Value string `json:"value"`
	Type  string `json:"type"`
}

type Postmaner struct {
	Info     Info       `json:"info"`
	Item     []*Item    `json:"item"`
	Auth     Auth       `json:"auth"`
	Event    []Event    `json:"event"`
	Variable []Variable `json:"variable"`
}