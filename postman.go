package postman

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"
)

type Config struct {
	Package     string
	TestFile    string
	PostmanFile string
	RouterFunc  string
	Variables   map[string]string
	PreTest     string
}

func (c *Config) Generate() error {

	testData := headerText(c)
	os.Remove(c.TestFile)
	postmanData, err := ioutil.ReadFile(c.PostmanFile)
	if err != nil {
		return err
	}
	var post *Postmaner
	jsonData := string(postmanData)
	for k, e := range c.Variables {
		jsonData = strings.Replace(jsonData, fmt.Sprintf("{{%v}}", k), e, -1)
	}
	err = json.Unmarshal([]byte(jsonData), &post)
	if err != nil {
		return err
	}

	for _, v := range post.Item {
		httpTests := []string{}
		fmt.Printf("Rendering Group: %v\n", v.Name)

		for _, item := range v.Item {
			fmt.Printf("  URL: %v | Method: %v %v\n", item.Request.URL.Raw, item.Request.Method, item.Request.Body.Raw)
			body := strings.Replace(item.Request.Body.Raw, `"`, `\"`, -1)
			body = strings.Replace(body, "\n", "", -1)
			innerData := fmt.Sprintf(`
		{
            Name: "%v",
            URL: "%v",
            Method: "%v",
            Body: "%v",
            ExpectedStatus: 200,
            ExpectedContains: nil,
        }`, item.Name, item.Request.URL.Raw, item.Request.Method, body)
			httpTests = append(httpTests, innerData)
		}

		testFunc := strings.Replace(v.Name, " ", "", -1)

		testData += `
// TestPostman` + testFunc + ` runs all the Postman tests within the ` + v.Name + ` group.
func TestPostman` + testFunc + `(t *testing.T) {

	tests := []HTTPTest{` + strings.Join(httpTests, ",") + `}

    for _, v := range tests {
        t.Run(v.Name, func(t *testing.T) {
            run, err := RunHTTPTest(v)
            assert.Nil(t, err)
            body, err := ioutil.ReadAll(run.Body)
            assert.Nil(t, err)
            assert.Equal(t, v.ExpectedStatus, run.StatusCode)
            if v.ExpectedContains != nil {
                stringBody := string(body)
                for _, c := range v.ExpectedContains {
                    assert.Contains(t, stringBody, c)
                }
            }
            t.Logf("Test %v got: %v\n", v.Name, string(body))
        })
	}

}
`
	}

	fmt.Printf("Writing to test file: %v \n", c.TestFile)
	f, err := os.Create(c.TestFile)
	if err != nil {
		return err
	}
	f.WriteString(testData)

	return f.Close()
}

func headerText(c *Config) string {
	return `// Code generated by go generate; DO NOT EDIT.
// This file was generated by github.com/hunterlong/postman on
// ` + time.Now().String() + `
// 
// This contains Go HTTP testing rendered from a postman JSON export

package ` + c.Package + `

import (
	"github.com/stretchr/testify/assert"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

// HTTPTest contains all the parameters for a HTTP Unit Test
type HTTPTest struct {
    Name string
    URL string
    Method string
    Body string
    ExpectedStatus int
    ExpectedContains []string
}

// RunHTTPTest accepts a HTTPTest type to execute the HTTP request
func RunHTTPTest(test HTTPTest) (*http.Response, error) {
    req, err := http.NewRequest(test.Method, test.URL, strings.NewReader(test.Body))
    if err != nil {
        return nil, err
    }
    rr := httptest.NewRecorder()
    ` + c.RouterFunc + `.ServeHTTP(rr, req)
    return rr.Result(), err
}

` + c.PreTest + `
`
}

type info struct {
	PostmanID string `json:"_postman_id"`
	Name      string `json:"name"`
	Schema    string `json:"schema"`
}

type item struct {
	Name string    `json:"name"`
	Item []subItem `json:"item"`
}

type subItem struct {
	Name     string        `json:"name"`
	Request  request       `json:"request"`
	Response []interface{} `json:"response"`
}

type request struct {
	Method string      `json:"method"`
	Header interface{} `json:"header"`
	Body   body        `json:"body"`
	URL    url         `json:"url"`
}

type url struct {
	Raw  string   `json:"raw"`
	Host []string `json:"host"`
	Path []string `json:"path"`
}

type body struct {
	Mode string `json:"mode"`
	Raw  string `json:"raw"`
}

type auth struct {
	Type   string `json:"type"`
	Bearer []struct {
		Key   string `json:"key"`
		Value string `json:"value"`
		Type  string `json:"type"`
	} `json:"bearer"`
}

type event struct {
	Listen string `json:"listen"`
	Script struct {
		ID   string   `json:"id"`
		Type string   `json:"type"`
		Exec []string `json:"exec"`
	} `json:"script"`
}

type variable struct {
	ID    string `json:"id"`
	Key   string `json:"key"`
	Value string `json:"value"`
	Type  string `json:"type"`
}

type Postmaner struct {
	Info     info       `json:"info"`
	Item     []*item    `json:"item"`
	Auth     auth       `json:"auth"`
	Event    []event    `json:"event"`
	Variable []variable `json:"variable"`
}
